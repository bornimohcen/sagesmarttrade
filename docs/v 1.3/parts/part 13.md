Part 13 = Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø­ÙØ¸Ø© (Portfolio) + Walk-Forward Optimization
Ù‡Ù†Ø§ Ù†Ø·Ù„Ø¹ Ù…Ù† Ù…Ø³ØªÙˆÙ‰ â€œØµÙÙ‚Ø© ÙˆØ§Ø­Ø¯Ø©â€ Ø¥Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ â€œÙ…Ø­ÙØ¸Ø© ÙƒØ§Ù…Ù„Ø© Ù…Ù† Ø§Ù„Ø£ØµÙˆÙ„ ÙˆØ§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øªâ€.

Ø±Ø­ Ø£Ø±ØªÙ‘Ø¨ Part 13 ÙƒØ°Ø§:

Ø§Ù„Ù‡Ø¯Ù Ù…Ù† Part 13

Portfolio Model (ÙƒÙŠÙ Ù†ÙˆØ²Ù‘Ø¹ Ø±Ø£Ø³ Ø§Ù„Ù…Ø§Ù„ Ø¨ÙŠÙ† Ø§Ù„Ø£ØµÙˆÙ„ ÙˆØ§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª)

ØªØ·ÙˆÙŠØ± RiskManager Ù„ÙŠØµØ¨Ø­ Portfolio-Aware

Portfolio Backtester (Ø§Ø®ØªØ¨Ø§Ø± Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù…Ø­ÙØ¸Ø©ØŒ Ù…Ø´ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·)

Walk-Forward Optimization (ØªÙ‚Ø³ÙŠÙ… Ø§Ù„ØªØ§Ø±ÙŠØ® In-Sample / Out-of-Sample)

Ø³ÙƒØ±Ø¨ØªØ§Øª CLI Ø§Ù„Ù…Ù‚ØªØ±Ø­Ø©

Prompt Ø¬Ø§Ù‡Ø² ØªØ¹Ø·ÙŠÙ‡ Ù„Ù€ AI Agent ÙŠÙ†ÙÙ‘Ø° Part 13 ÙÙŠ Ø§Ù„Ø±ÙŠØ¨Ùˆ

1ï¸âƒ£ Ø§Ù„Ù‡Ø¯Ù Ù…Ù† Part 13

Ø§Ù„Ø¢Ù† Ø¹Ù†Ø¯Ùƒ:

Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ù…ØªØ¹Ø¯Ø¯Ø© (news_quick_trade, trend_follow, ÙˆØºÙŠØ±Ù‡Ø§ Ù…Ø³ØªÙ‚Ø¨Ù„Ø§Ù‹)

Backtesting + Optimization Ø¹Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© ÙˆØ§Ø­Ø¯Ø© (Part 11â€“12)

ÙÙŠ Part 13 Ù†Ø±ÙŠØ¯:

Portfolio-level control:

ÙƒÙ… Ø±Ø£Ø³ Ø§Ù„Ù…Ø§Ù„ ÙŠØ±ÙˆØ­ Ù„ÙƒÙ„:

Ø£ØµÙ„ (symbol)

Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© (strategy)

Ø­Ø¯ÙˆØ¯ Ù…Ø«Ù„:

max % per symbol

max % per asset_class (equities / crypto / forex)

max % per strategy

Walk-forward optimization:

ØªÙ‚Ø³ÙŠÙ… Ø§Ù„ØªØ§Ø±ÙŠØ® Ø¥Ù„Ù‰:

ÙØªØ±Ø© ØªØ¯Ø±ÙŠØ¨ (In-Sample) â†’ Ù†Ø¶Ø¨Ø· Ø§Ù„Ø¨Ø§Ø±Ø§Ù…ØªØ±Ø§Øª

ÙØªØ±Ø© Ø§Ø®ØªØ¨Ø§Ø± (Out-of-Sample) â†’ Ù†Ø®ØªØ¨Ø± Ø¨Ø¯ÙˆÙ† Ù„Ù…Ø³ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª

ØªÙƒØ±Ø§Ø± Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¹Ù„Ù‰ Ù†ÙˆØ§ÙØ° Ù…ØªØ­Ø±ÙƒØ© (rolling windows)

Ù‚ÙŠØ§Ø³ Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­Ø³ÙŠÙ† (Ù„Ù…Ù†Ø¹ overfitting)

2ï¸âƒ£ Portfolio Model (ØªÙˆØ²ÙŠØ¹ Ø±Ø£Ø³ Ø§Ù„Ù…Ø§Ù„)
ğŸ§± 13.1 â€” ØªØ¹Ø±ÙŠÙ PortfolioConfig

Ù…Ù„Ù Ø¬Ø¯ÙŠØ¯: sagetrade/portfolio/config.py

Ù†Ø¹Ø±Ù‘Ù:

from __future__ import annotations
from dataclasses import dataclass, field
from typing import Dict

@dataclass
class SymbolAllocation:
    # Ù†Ø³Ø¨Ø© Ø±Ø£Ø³ Ø§Ù„Ù…Ø§Ù„ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯ÙØ© Ù„Ù‡Ø°Ø§ Ø§Ù„Ø±Ù…Ø² Ù…Ù† Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø­ÙØ¸Ø©
    target_weight: float              # Ù…Ø«Ù„Ø§Ù‹ 0.2 = 20%
    max_weight: float = 0.3           # Ø­Ø¯ Ø£Ù‚ØµÙ‰
    max_concurrent_trades: int = 3    # Ø£Ù‚ØµÙ‰ Ø¹Ø¯Ø¯ ØµÙÙ‚Ø§Øª Ù…ÙØªÙˆØ­Ø© Ø¹Ù„Ù‰ Ù‡Ø°Ø§ Ø§Ù„Ø±Ù…Ø²

@dataclass
class StrategyAllocation:
    # Ù†Ø³Ø¨Ø© Ø±Ø£Ø³ Ø§Ù„Ù…Ø§Ù„ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯ÙØ© Ù„Ù‡Ø°Ù‡ Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©
    target_weight: float
    max_weight: float

@dataclass
class AssetClassAllocation:
    target_weight: float
    max_weight: float

@dataclass
class PortfolioConfig:
    symbols: Dict[str, SymbolAllocation] = field(default_factory=dict)
    strategies: Dict[str, StrategyAllocation] = field(default_factory=dict)
    asset_classes: Dict[str, AssetClassAllocation] = field(default_factory=dict)

    max_total_leverage: float = 1.0
    max_positions: int = 50


ÙˆØªØ±Ø¨Ø·Ù‡ Ø¨Ø§Ù„Ù€ settings:

portfolio:
  max_total_leverage: 1.5
  max_positions: 30

  symbols:
    BTCUSD:
      target_weight: 0.2
      max_weight: 0.3
      max_concurrent_trades: 5
    AAPL:
      target_weight: 0.2
      max_weight: 0.25

  strategies:
    news_quick_trade:
      target_weight: 0.3
      max_weight: 0.5
    trend_follow:
      target_weight: 0.7
      max_weight: 0.9

  asset_classes:
    crypto:
      target_weight: 0.3
      max_weight: 0.5
    equity:
      target_weight: 0.5
      max_weight: 0.7
    forex:
      target_weight: 0.2
      max_weight: 0.3

3ï¸âƒ£ ØªØ·ÙˆÙŠØ± RiskManager Ù„ÙŠØµØ¨Ø­ Portfolio-Aware
ğŸ§± 13.2 â€” PortfolioExposureState

Ù…Ù„Ù: sagetrade/portfolio/state.py

from __future__ import annotations
from dataclasses import dataclass, field
from typing import Dict

@dataclass
class PortfolioExposure:
    total_notional: float = 0.0
    by_symbol: Dict[str, float] = field(default_factory=dict)
    by_strategy: Dict[str, float] = field(default_factory=dict)
    by_asset_class: Dict[str, float] = field(default_factory=dict)

ğŸ§± 13.3 â€” ØªØ­Ø¯ÙŠØ« RiskManager Ù„ÙŠØ­Ø³Ø¨ Ù‡Ø°Ù‡ Ø§Ù„Ù€ exposures

ÙÙŠ RiskManager.refresh_from_broker():

Ø¨Ø¯Ù„ Ù…Ø§ ÙŠØ­Ø³Ø¨ ÙÙ‚Ø· open_notional_by_symbol â†’ Ù†Ø¶ÙŠÙ:

by_strategy (Ù…Ù† Ø§Ù„Ù€ position.strategy_name)

by_asset_class (Ù…Ù† universe: symbol -> asset_class Ù…Ø«Ù„ equity / crypto / forex)

ğŸ§± 13.4 â€” Ø¯Ø§Ù„Ø© can_open_trade ØªØ£Ø®Ø° ÙÙŠ Ø§Ù„Ø§Ø¹ØªØ¨Ø§Ø± Ø§Ù„Ù€ PortfolioConfig

ÙÙŠ RiskManager.can_open_trade(symbol, notional, strategy_name, asset_class):

Ø¨Ø§Ù„Ø¥Ø¶Ø§ÙØ© Ø¥Ù„Ù‰ checks Ø§Ù„Ø­Ø§Ù„ÙŠØ© (max_trade_risk_pct, max_daily_loss, â€¦):

Ù†Ø¶ÙŠÙ:

Ø­Ø¯ Ø¹Ø¯Ø¯ Ø§Ù„ØµÙÙ‚Ø§Øª Ø§Ù„Ù…ÙØªÙˆØ­Ø©:

if total_positions >= portfolio_cfg.max_positions:
    return False, "portfolio_max_positions_reached"


ÙˆØ²Ù† Ø§Ù„Ø±Ù…Ø²:

current_symbol_notional = exposure.by_symbol.get(symbol, 0.0)
new_symbol_weight = (current_symbol_notional + notional) / equity

cfg_sym = portfolio_cfg.symbols.get(symbol)
if cfg_sym:
    if new_symbol_weight > cfg_sym.max_weight:
        return False, "symbol_max_weight_exceeded"


ÙˆØ²Ù† Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©:

current_strat_notional = exposure.by_strategy.get(strategy_name, 0.0)
new_strat_weight = (current_strat_notional + notional) / equity

cfg_str = portfolio_cfg.strategies.get(strategy_name)
if cfg_str:
    if new_strat_weight > cfg_str.max_weight:
        return False, "strategy_max_weight_exceeded"


ÙˆØ²Ù† Ø§Ù„Ù€ asset_class (equity / crypto / forex):

current_ac_notional = exposure.by_asset_class.get(asset_class, 0.0)
new_ac_weight = (current_ac_notional + notional) / equity

cfg_ac = portfolio_cfg.asset_classes.get(asset_class)
if cfg_ac:
    if new_ac_weight > cfg_ac.max_weight:
        return False, "asset_class_max_weight_exceeded"


leverage Ø¹Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ù…Ø­ÙØ¸Ø©:

new_total_notional = exposure.total_notional + notional
leverage = new_total_notional / equity
if leverage > portfolio_cfg.max_total_leverage:
    return False, "portfolio_max_leverage_exceeded"


ÙƒØ°Ø§ Ø§Ù„Ù€ RiskManager ÙŠØµÙŠØ± â€œPortfolio-awareâ€ Ø¨Ø¯ÙˆÙ† Ù…Ø§ ØªØºÙŠÙ‘Ø± ÙƒØ«ÙŠØ± ÙÙŠ Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ù†ÙØ³Ù‡Ø§.

4ï¸âƒ£ Portfolio Backtester

Ø§Ù„Ù€ backtest Ø§Ù„Ø­Ø§Ù„ÙŠ ÙÙŠ Part 11 ÙŠØ´ØªØºÙ„ per symbolØ› Ø§Ù„Ø¢Ù† Ù†Ø±ÙŠØ¯:

Ù†ÙØ³ Ø§Ù„Ù€ runner Ù„ÙƒÙ† Ù…Ø¹:

Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ù…ØªØ¹Ø¯Ø¯Ø©

PortfolioConfig

RiskManager Ù…Ø­Ø¯Ø«

Ø§Ù„Ø®Ø·ÙˆØ§Øª:

Ø¯Ø§Ø®Ù„ run_backtest:

Ù†Ù‚Ø±Ø£ PortfolioConfig Ù…Ù† settings

Ù†Ù…Ø±Ø±Ù‡Ø§ Ù„Ù„Ù€ RiskManager

Ø¹Ù†Ø¯ Ø­Ø³Ø§Ø¨ qty ÙÙŠ Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©:

Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© ØªÙ‚ØªØ±Ø­ qty_raw = strat.position_size(...)

Ø«Ù… Ù†Ø·Ø¨Ù‘Ù‚ scaling Ø­Ø³Ø¨ Ø§Ù„ØªØ®ØµÙŠØµ:

# equity, portfolio_cfg, exposure Ù…ÙˆØ¬ÙˆØ¯ÙŠÙ†
symbol_cfg = portfolio_cfg.symbols.get(symbol)
strategy_cfg = portfolio_cfg.strategies.get(strat.name)

symbol_target_weight = symbol_cfg.target_weight if symbol_cfg else None
strategy_target_weight = strategy_cfg.target_weight if strategy_cfg else None

# Ù…Ø«Ø§Ù„ Ø¨Ø³ÙŠØ·: Ù„Ùˆ exposure Ø£Ù‚Ù„ Ù…Ù† target_weight Ù†Ø³Ù…Ø­ Ø¨ØµÙÙ‚Ø© ÙƒØ§Ù…Ù„Ø©ØŒ
# Ù„Ùˆ Ù‚Ø±ÙŠØ¨ Ù…Ù† targetØŒ Ù†Ø®ÙÙ‘Ø¶ Ø§Ù„Ø­Ø¬Ù….
# ÙƒØ¨Ø¯Ø§ÙŠØ©: Ù†Ù‚Ø¯Ø± Ù†Ø®Ù„ÙŠ qty_raw ÙƒÙ…Ø§ Ù‡ÙˆØŒ ÙˆÙ†Ø¹ØªÙ…Ø¯ ÙÙ‚Ø· Ø¹Ù„Ù‰ can_open_trade Ù„Ù…Ù†Ø¹ ØªØ¬Ø§ÙˆØ² max_weight.


ÙƒØ¨Ø¯Ø§ÙŠØ© Ø®Ù„ÙŠÙ‡ Ø¨Ø³ÙŠØ·: Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© ØªØ­Ø¯Ø¯ Ø§Ù„Ø­Ø¬Ù…ØŒ ÙˆØ§Ù„Ù€ RiskManager + PortfolioConfig ÙŠÙ…Ù†Ø¹ÙˆÙ† Ø§Ù„Ø£ÙˆÙØ± Ø¥ÙƒØ³Ø¨ÙˆØ¬Ø±. Ù„Ùˆ Ø­Ø¨ÙŠØª later Ù†Ø¶ÙŠÙ â€œsmart scalingâ€.

5ï¸âƒ£ Walk-Forward Optimization

Ù‡Ø°Ø§ Ø£Ù‡Ù… Ø¬Ø²Ø¡ Ø¹Ù„Ù…ÙŠØ§Ù‹ ğŸ‘‡

ğŸ§± 13.5 â€” ØªØ¹Ø±ÙŠÙ WalkForwardSegment & Result

Ù…Ù„Ù: sagetrade/backtest/walk_forward.py

from __future__ import annotations
from dataclasses import dataclass
from datetime import date
from typing import List, Dict, Any

@dataclass
class WalkForwardSegment:
    train_start: date
    train_end: date
    test_start: date
    test_end: date

@dataclass
class WalkForwardResult:
    segments: List[WalkForwardSegment]
    per_segment_metrics: List[Dict[str, Any]]  # metrics Ù„ÙƒÙ„ segment
    overall_metrics: Dict[str, Any]

ğŸ§± 13.6 â€” Ø¨Ù†Ø§Ø¡ segments rolling

Ù…Ø«Ø§Ù„:

Ù„Ø¯ÙŠÙƒ Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† 2024-01-01 Ø¥Ù„Ù‰ 2024-12-31

ØªØ±ÙŠØ¯:

Train 3 Ø£Ø´Ù‡Ø± + Test Ø´Ù‡Ø± 1

Ù…ØªØ­Ø±Ù‘ÙƒØ© Ø´Ù‡Ø± Ø¨Ø´Ù‡Ø±

Ø¯Ø§Ù„Ø©:

def build_walk_forward_segments(
    start: date,
    end: date,
    train_months: int,
    test_months: int,
) -> list[WalkForwardSegment]:
    ...


ØªÙÙ†ØªØ¬ segments Ù…Ø«Ù„:

Train: Janâ€“Mar / Test: Apr

Train: Febâ€“Apr / Test: May

Train: Marâ€“May / Test: Jun
â€¦Ø¥Ù„Ø®

ğŸ§± 13.7 â€” ØªØ´ØºÙŠÙ„ optimization Ø«Ù… test Ù„ÙƒÙ„ segment

Workflow Ù„ÙƒÙ„ segment:

In-Sample (Train):

ØªØ´ØºÙ‘Ù„ run_param_search_for_strategy (Ù…Ù† Part 12)

ØªØ³ØªØ®Ø±Ø¬ Ø£ÙØ¶Ù„ params Ù„ÙƒÙ„ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©

Out-of-Sample (Test):

ØªØ¨Ù†ÙŠ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ù€ params

ØªØ´ØºÙ‘Ù„ run_backtest Ø¹Ù„Ù‰ ÙØªØ±Ø© test ÙÙ‚Ø·

ØªØ®Ø²Ù‘Ù† metrics ÙÙŠ per_segment_metrics

Ø¯Ø§Ù„Ø© Ø±Ø¦ÙŠØ³ÙŠØ©:
def run_walk_forward(
    symbols: list[str],
    start: date,
    end: date,
    initial_equity: float,
    train_months: int,
    test_months: int,
    strategy_param_grids: dict[str, dict[str, list]],
    load_history_fn,
) -> WalkForwardResult:
    """
    strategy_param_grids: Ù…Ø«Ù„:
    {
      "news_quick_trade": {"min_impact_score": [...], "risk_factor": [...]},
      "trend_follow": {...}
    }
    """
    segments = build_walk_forward_segments(start, end, train_months, test_months)
    per_segment_metrics: list[dict[str, Any]] = []

    for seg in segments:
        # 1) optimization Ø¹Ù„Ù‰ seg.train_start -> seg.train_end
        #   Ù„ÙƒÙ„ strategy_name ÙÙŠ strategy_param_grids
        best_params_per_strategy = {}
        for strat_name, grid in strategy_param_grids.items():
            res_df = run_param_search_for_strategy(
                strat_name,
                grid,
                symbols,
                seg.train_start,
                seg.train_end,
                initial_equity,
                load_history_fn,
            )
            # Ø§Ø®ØªÙŠØ§Ø± Ø£ÙØ¶Ù„ row Ø­Ø³Ø¨ "score"
            ...

        # 2) backtest Ø¹Ù„Ù‰ test segment Ø¨Ø§Ø³ØªØ¹Ù…Ø§Ù„ best_params_per_strategy
        #   ØªØ­ØªØ§Ø¬ runner ÙŠÙ‚Ø¨Ù„ strategies Ù…Ø¹ params
        #   ØªØ±Ø¬Ø¹ trades Ùˆ metrics
        test_trades = run_backtest_with_custom_strategies(...)

        metrics = compute_metrics(test_trades, initial_equity)
        metrics["train_start"] = seg.train_start.isoformat()
        metrics["train_end"] = seg.train_end.isoformat()
        metrics["test_start"] = seg.test_start.isoformat()
        metrics["test_end"] = seg.test_end.isoformat()

        per_segment_metrics.append(metrics)

    # overall metrics: Ù…Ù…ÙƒÙ† total PnL + curve Ø¹Ù„Ù‰ ÙƒÙ„ Ø§Ù„ÙØªØ±Ø§Øª test
    # Ø£Ùˆ Ù…ØªÙˆØ³Ø· win_rate & max_drawdown Ø¨Ø­Ø³Ø§Ø¨ Ø­Ø³Ø¨ Ø§Ù„Ø­Ø¬Ù…
    overall = {...}

    return WalkForwardResult(
        segments=segments,
        per_segment_metrics=per_segment_metrics,
        overall_metrics=overall,
    )


Ø§Ù„Ù‡Ø¯Ù: ÙŠÙƒÙˆÙ† Ø¹Ù†Ø¯Ùƒ performance Out-of-Sample Ø­Ù‚ÙŠÙ‚ÙŠ Ø¨Ø¹Ø¯ ÙƒÙ„ Ù…Ø±Ø­Ù„Ø© tuning.

6ï¸âƒ£ Ø³ÙƒØ±Ø¨ØªØ§Øª CLI Ù…Ù‚ØªØ±Ø­Ø©
1) scripts/portfolio_backtest.py

Ø´Ø¨ÙŠÙ‡ Ø¨Ù€ backtest.py Ù„ÙƒÙ†:

ÙŠÙ‚Ø±Ø£ portfolio.* Ù…Ù† settings

ÙŠØ·Ø¨Ø¹:

exposure per symbol/strategy/asset class

metrics Ø¹Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ù…Ø­ÙØ¸Ø©

2) scripts/walk_forward.py

Args Ù…Ø«Ø§Ù„:

python scripts/walk_forward.py \
  --symbols BTCUSD,AAPL,EURUSD \
  --start 2024-01-01 \
  --end 2024-12-31 \
  --train-months 3 \
  --test-months 1


Ø§Ù„Ù†Ø§ØªØ¬:

walk_forward_<timestamp>.json ÙÙŠÙ‡:

per segment metrics

overall_metrics

walk_forward_<timestamp>.csv

Ø±Ø¨Ù…Ø§ equity curve Ù„ÙƒÙ„ test segment

7ï¸âƒ£ Prompt Ø¬Ø§Ù‡Ø² Ù„Ù€ AI Agent Ù„ØªÙ†ÙÙŠØ° Part 13 Ø¹Ù„Ù‰ Ø§Ù„Ø±ÙŠØ¨Ùˆ

Ø§Ù†Ø³Ø® Ù‡Ø°Ø§ Ø§Ù„ÙƒÙ„Ø§Ù… ÙƒÙ…Ø§ Ù‡Ùˆ Ù„ÙˆÙƒÙŠÙ„ AI Ø§Ù„Ù„ÙŠ ÙŠØ¹Ø¯Ù‘Ù„ Ø§Ù„ÙƒÙˆØ¯:

You are a senior quant and portfolio engineer working on my project SAGE SmartTrade.

CONTEXT:
- The project already has:
  - Multiple strategies (e.g. news_quick_trade, trend_follow).
  - A RiskManager and RiskState.
  - Backtest runner + reporting (Phase 11).
  - Parameter optimization for single strategies (Phase 12).

GOAL (Phase 13):
- Introduce portfolio-level controls (capital allocation per symbol, strategy, and asset class).
- Extend RiskManager to be portfolio-aware.
- Add walk-forward optimization (train/test segments) that uses the existing backtest and param-search tools.

TASKS:

1) Portfolio configuration.

   - File: `sagetrade/portfolio/config.py`
   - Define dataclasses:

     ```python
     @dataclass
     class SymbolAllocation:
         target_weight: float
         max_weight: float = 0.3
         max_concurrent_trades: int = 3

     @dataclass
     class StrategyAllocation:
         target_weight: float
         max_weight: float

     @dataclass
     class AssetClassAllocation:
         target_weight: float
         max_weight: float

     @dataclass
     class PortfolioConfig:
         symbols: Dict[str, SymbolAllocation] = field(default_factory=dict)
         strategies: Dict[str, StrategyAllocation] = field(default_factory=dict)
         asset_classes: Dict[str, AssetClassAllocation] = field(default_factory=dict)
         max_total_leverage: float = 1.0
         max_positions: int = 50
     ```

   - Integrate with config/settings.yaml under a new `portfolio` section, e.g.:

     ```yaml
     portfolio:
       max_total_leverage: 1.5
       max_positions: 30
       symbols:
         BTCUSD:
           target_weight: 0.2
           max_weight: 0.3
           max_concurrent_trades: 5
       strategies:
         news_quick_trade:
           target_weight: 0.3
           max_weight: 0.5
       asset_classes:
         crypto:
           target_weight: 0.3
           max_weight: 0.5
     ```

2) Portfolio exposure state and RiskManager integration.

   - File: `sagetrade/portfolio/state.py`
     - Define a `PortfolioExposure` dataclass with:
       - total_notional: float
       - by_symbol: dict[str, float]
       - by_strategy: dict[str, float]
       - by_asset_class: dict[str, float]
   - In `RiskManager.refresh_from_broker()`:
     - Compute and store portfolio exposures:
       - total_notional
       - per symbol
       - per strategy (using position.strategy_name)
       - per asset class (using `universe` mapping symbol â†’ asset_class).
   - Extend `RiskManager.can_open_trade(...)` to accept:
     - `symbol`, `notional`, `strategy_name`, `asset_class`.
   - Within `can_open_trade`, in addition to existing checks:
     - Enforce:
       - portfolio.max_positions
       - per-symbol max_weight
       - per-strategy max_weight
       - per-asset-class max_weight
       - max_total_leverage (total_notional / equity).

3) Make the backtest runner portfolio-aware.

   - In `sagetrade/backtest/runner.py`:
     - Load `PortfolioConfig` from settings.
     - Initialize `RiskManager` with both `RiskState` and `PortfolioConfig` (or make PortfolioConfig accessible).
     - When calling `risk_manager.can_open_trade(...)`, pass `symbol`, `notional`, `strategy_name`, and `asset_class`.
     - Keep strategy-level position sizing logic unchanged for now, but rely on RiskManager+PortfolioConfig to block trades that exceed weights or leverage limits.

4) Walk-forward optimization framework.

   - File: `sagetrade/backtest/walk_forward.py`
   - Define:

     ```python
     @dataclass
     class WalkForwardSegment:
         train_start: date
         train_end: date
         test_start: date
         test_end: date

     @dataclass
     class WalkForwardResult:
         segments: list[WalkForwardSegment]
         per_segment_metrics: list[dict[str, Any]]
         overall_metrics: dict[str, Any]
     ```

   - Implement a helper:

     ```python
     def build_walk_forward_segments(
         start: date,
         end: date,
         train_months: int,
         test_months: int,
     ) -> list[WalkForwardSegment]:
         ...
     ```

     that creates rolling train/test windows (e.g. 3-month train, 1-month test, stepped by test window).

   - Implement:

     ```python
     def run_walk_forward(
         symbols: list[str],
         start: date,
         end: date,
         initial_equity: float,
         train_months: int,
         test_months: int,
         strategy_param_grids: dict[str, dict[str, list]],
         load_history_fn,
     ) -> WalkForwardResult:
         ...
     ```

     For each `WalkForwardSegment`:
       1. TRAIN:
          - For each strategy in `strategy_param_grids`:
            - Call `run_param_search_for_strategy(...)` (from Phase 12) on [train_start, train_end].
            - Select the best param combination based on a score (e.g. total_return / abs(max_drawdown)).
       2. TEST:
          - Build strategy instances with the best params.
          - Run a backtest on [test_start, test_end] using these strategies and the portfolio-aware RiskManager.
          - Compute metrics for the test period and append to `per_segment_metrics`.

     - Compute `overall_metrics` by aggregating all test-period trades (e.g. total PnL, overall win_rate, overall max_drawdown).

5) CLI for walk-forward.

   - File: `scripts/walk_forward.py`
   - Arguments:
     - `--symbols`
     - `--start`, `--end`
     - `--train-months`, `--test-months`
     - `--initial-equity`
     - `--out-dir`
   - Inside:
     - Define `strategy_param_grids` (can be hard-coded for now for strategies like news_quick_trade, trend_follow).
     - Call `run_walk_forward(...)`.
     - Save:
       - `walk_forward_<timestamp>.json` containing:
         - segments
         - per_segment_metrics
         - overall_metrics
       - Optionally `walk_forward_<timestamp>.csv` with per-segment metrics.
     - Print a human-readable summary:
       - overall total_return, max_drawdown, win_rate
       - best and worst segments by performance.

STYLE:
- Reuse existing backtest / param_search / reporting utilities.
- Use Python 3.11+ typing and dataclasses.
- Keep functions modular and separate:
  - portfolio config
  - risk extensions
  - walk-forward logic
  - CLI script.

OUTPUT:
- Provide updated/new files as code blocks, e.g.:

  # FILE: sagetrade/portfolio/config.py
  ...
  # FILE: sagetrade/portfolio/state.py
  ...
  # FILE: sagetrade/risk/manager.py
  ...
  # FILE: sagetrade/backtest/walk_forward.py
  ...
  # FILE: scripts/walk_forward.py
  ...
