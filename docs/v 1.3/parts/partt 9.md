Part 9 = AI Brain ÿ≠ŸÇŸäŸÇŸä ŸÅŸàŸÇ ÿßŸÑŸÜÿ∏ÿßŸÖ ŸÉÿßŸÖŸÑ:
Ÿäÿ≥ÿßÿπÿØ ŸÅŸä ÿ™ÿµŸÅŸäÿ© ÿßŸÑÿ•ÿ¥ÿßÿ±ÿßÿ™ÿå ÿ¥ÿ±ÿ≠ ÿßŸÑÿµŸÅŸÇÿßÿ™ÿå ŸàŸÖÿ±ÿßÿ¨ÿπÿ© ÿßŸÑÿ£ÿØÿßÿ° + Ÿäÿ∑ŸÑÿπ ÿßŸÑŸÉŸÑÿßŸÖ ÿßŸÑÿ≠ŸÑŸà ÿπŸÑŸâ ÿ™ŸäŸÑŸäÿ∫ÿ±ÿßŸÖ.

ÿ±ÿ≠ ÿ£ÿπŸÖŸÑŸá ŸÑŸÉ ŸÉÿßŸÑÿ™ÿßŸÑŸä:

ÿßŸÑŸÅŸÉÿ±ÿ© ÿßŸÑÿπÿßŸÖÿ© ŸÑÿ∑ÿ®ŸÇÿ© ÿßŸÑŸÄ AI ŸÅŸä ÿßŸÑŸÖÿ¥ÿ±Ÿàÿπ

ÿ™ŸÇÿ≥ŸäŸÖ Part 9 ŸÑŸÖŸáÿßŸÖ Ÿàÿßÿ∂ÿ≠ÿ©

ÿ™ÿµŸÖŸäŸÖ ÿßŸÑŸÄ Data Models (AISignalAdvice, TradeExplanation, TradeReview)

ÿ™ÿµŸÖŸäŸÖ LLM Client ÿπÿßŸÖ (ÿ®ÿØŸàŸÜ ÿ±ÿ®ÿ∑ ÿ®ŸÖÿ≤ŸàŸëÿØ ŸÖÿπŸäŸëŸÜ)

AISignalAdvisor: ŸÉŸäŸÅ Ÿäÿ™ÿØÿÆŸÑ ŸÇÿ®ŸÑ ÿ™ŸÜŸÅŸäÿ∞ ÿßŸÑÿµŸÅŸÇÿ©

AITradeExplainer: ŸÉŸäŸÅ Ÿäÿ¥ÿ±ÿ≠ ÿßŸÑÿµŸÅŸÇÿ© ÿ®ŸÑÿ∫ÿ© ÿ∑ÿ®ŸäÿπŸäÿ© (ŸÑÿ™ŸäŸÑŸäÿ∫ÿ±ÿßŸÖ ŸàÿßŸÑŸÑŸàÿ¨)

ÿØŸÖÿ¨ AI ŸÖÿπ Telegram bot (ÿ£ŸàÿßŸÖÿ± ŸÖÿ´ŸÑ /explain_last)

ÿ•ÿ∂ÿßŸÅÿ© ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÄ AI ŸÅŸä settings.yaml

Prompt ÿ¨ÿßŸáÿ≤ ÿ™ÿπÿ∑ŸäŸá ŸÑŸÄ AI Agent ŸäŸÜŸÅÿ∞ Part 9 ÿπŸÑŸâ ÿßŸÑŸÉŸàÿØ

üß† 1) ŸÖÿß ŸáŸä ÿ∑ÿ®ŸÇÿ© ÿßŸÑŸÄ AI ÿßŸÑŸÑŸä ŸÜÿ±ŸäÿØŸáÿß ŸÅŸä SAGE SmartTradeÿü

ŸÜÿ±ŸäÿØ ÿ´ŸÑÿßÿ´ ÿ£ÿØŸàÿßÿ± ÿ±ÿ¶Ÿäÿ≥Ÿäÿ©:

AISignalAdvisor

Ÿäÿ£ÿÆÿ∞ CompositeSignal + RiskState + StrategyProposal

Ÿäÿ±ÿßÿ¨ÿπŸáÿß (conceptually)

Ÿäÿ±ÿ¨ÿπ:

ŸáŸÑ Ÿäÿ±Ÿâ ÿ£ŸÜ ÿßŸÑÿµŸÅŸÇÿ© ŸÖŸÜÿ∑ŸÇŸäÿ©ÿü (approve / caution / reject_suggest_flat)

ÿ•ŸÜ ÿ£ÿ≠ÿ®ÿ®ÿ™: ÿ™ÿπÿØŸäŸÑ ÿ®ÿ≥Ÿäÿ∑ ŸÅŸä direction ÿ£Ÿà confidence

ÿ™ÿπŸÑŸäŸÇ ŸÇÿµŸäÿ± ‚ÄúReasoning‚Äù (ŸäŸèÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸä ÿßŸÑŸÑŸàÿ¨ Ÿà telegram)

AITradeExplainer

ÿ®ÿπÿØ ŸÅÿ™ÿ≠ ÿµŸÅŸÇÿ© (ÿ£Ÿà ÿ•ÿ∫ŸÑÿßŸÇŸáÿß)ÿå Ÿäÿ£ÿÆÿ∞:

CompositeSignal

ÿßŸÑÿßÿ≥ÿ™ÿ±ÿßÿ™Ÿäÿ¨Ÿäÿ©

ÿ≠ÿ¨ŸÖ ÿßŸÑŸÖÿÆÿßÿ∑ÿ±ÿ©

ÿ≥ÿ®ÿ® ÿßŸÑÿØÿÆŸàŸÑ/ÿßŸÑÿÆÿ±Ÿàÿ¨

Ÿäÿ∑ŸÑÿπ ŸÜÿµ Ÿàÿßÿ∂ÿ≠ (ÿ®ÿßŸÑÿπÿ±ÿ®Ÿäÿ©/ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ©) Ÿäÿ¥ÿ±ÿ≠:

ŸÑŸÖÿßÿ∞ÿß ÿØÿÆŸÑŸÜÿßÿü

ŸÖÿß ŸáŸä ÿßŸÑŸÖÿÆÿßÿ∑ÿ±ÿü

ŸÉŸäŸÅ ŸÜÿ™ÿßÿ®ÿπ ÿßŸÑÿµŸÅŸÇÿ©ÿü

Post-Trade Reviewer (ÿßÿÆÿ™Ÿäÿßÿ±Ÿä ÿßŸÑÿ¢ŸÜ)

ÿ®ÿπÿØ ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑÿµŸÅŸÇÿ©:

ŸäÿπŸÖŸÑ ‚Äúmini report‚Äù: ŸÖÿßÿ∞ÿß ÿ™ÿπŸÑŸÖŸÜÿß ŸÖŸÜ ÿßŸÑÿµŸÅŸÇÿ©ÿü

ŸÖŸÖŸÉŸÜ ŸÜÿ§ÿ¨ŸÑŸá ŸÑŸÑŸÖÿ±ÿ≠ŸÑÿ© ÿßŸÑŸÇÿßÿØŸÖÿ©ÿå ŸÑŸÉŸÜ ŸÜÿ¨ŸáŸëÿ≤ ŸÑŸá Ÿàÿßÿ¨Ÿáÿ© (Interface).

üß© 2) ÿ™ŸÇÿ≥ŸäŸÖ Part 9 ÿ•ŸÑŸâ ŸÖŸáÿßŸÖ
üß± 9.1 ‚Äî ÿ•ÿ∂ÿßŸÅÿ© ÿ•ÿπÿØÿßÿØÿßÿ™ AI ŸÅŸä config/settings.yaml

ŸÇÿ≥ŸÖ ai::

provider (ŸÖÿ´ŸÑÿßŸã "openai", "local", "mock")

model

max_tokens

language (en/ar)

ŸÖŸÅÿ™ÿßÿ≠ API ÿπÿ®ÿ± Env vars

üß± 9.2 ‚Äî ÿ™ÿµŸÖŸäŸÖ Data Models ŸÑÿ∑ÿ®ŸÇÿ© AI

ŸÖŸÑŸÅ: sagetrade/ai/models.py

AISignalAdvice

AITradeExplanation

(ÿßÿÆÿ™Ÿäÿßÿ±Ÿä) AITradeReview

üß± 9.3 ‚Äî LLMClient abstraction

ŸÖŸÑŸÅ: sagetrade/ai/client.py

LLMClientBase (interface)

EnvLLMClient (ŸäŸÇÿ±ÿ£ ŸÖŸÅÿ™ÿßÿ≠ ŸÖŸÜ envÿå Ÿäÿ±ÿ≥ŸÑ prompt ŸàŸäÿ±ÿ¨ÿπ ŸÜÿµ)

ÿ≠ÿßŸÑŸäÿßŸã ŸÜÿÆŸÑŸäŸá ‚Äústub‚Äù (ÿ£ŸÜÿ™ ŸÑÿßÿ≠ŸÇÿßŸã ÿ™ÿ±ÿ®ÿ∑Ÿá ÿ®ŸÄ OpenAI ÿ£Ÿà ÿ∫Ÿäÿ±Ÿá).

üß± 9.4 ‚Äî AISignalAdvisor

ŸÖŸÑŸÅ: sagetrade/ai/signal_advisor.py

ÿØÿßŸÑÿ© / ŸÉŸÑÿßÿ≥:

AISignalAdvisor.review_trade_candidate(symbol, composite, strategy_name, risk_state) -> AISignalAdvice

Ÿäÿ®ŸÜŸä prompt ŸÜÿµŸä ŸÖŸÜ:

ÿßŸÑÿßÿ™ÿ¨ÿßŸáÿå score, confidence

ÿ≠ÿßŸÑÿ© ÿßŸÑŸÖÿÆÿßÿ∑ÿ±

ŸÜŸàÿπ ÿßŸÑÿßÿ≥ÿ™ÿ±ÿßÿ™Ÿäÿ¨Ÿäÿ©

ŸäŸÜÿßÿØŸä LLMClient ‚Üí Ÿäÿ±ÿ¨ÿπ advice + reasoning

ŸÑŸà API ŸÖÿ¥ ŸÖÿ™ŸàŸÅÿ± ‚Üí fallback (ŸÖŸÜÿ∑ŸÇ rule-based ÿ®ÿ≥Ÿäÿ∑)

üß± 9.5 ‚Äî AITradeExplainer

ŸÖŸÑŸÅ: sagetrade/ai/trade_explainer.py

ÿØÿßŸÑÿ©:

explain_open_trade(order, position, composite, strategy_name, risk_state) -> AITradeExplanation

explain_closed_trade(position, pnl, holding_period, composite_at_entry, strategy_name) -> AITradeExplanation

ÿ™ÿ≥ÿ™ÿÆÿØŸÖ LLMClient ŸÑÿ•ŸÜÿ™ÿßÿ¨ ŸÜÿµ explanation ÿ¨ÿßŸáÿ≤ ŸÑÿ™ŸäŸÑŸäÿ∫ÿ±ÿßŸÖ.

üß± 9.6 ‚Äî ÿØŸÖÿ¨ AI ŸÖÿπ Trading Loop + Telegram bot

ŸÇÿ®ŸÑ ÿ•ÿ±ÿ≥ÿßŸÑ order:

ŸÜÿ≥ÿ™ÿØÿπŸä AISignalAdvisor

ŸÜŸÇÿØÿ±:

ŸÜÿ∑ŸÑÿ® ŸÖŸÜŸá approval ŸÖŸÜÿ∑ŸÇŸä (ŸÖÿ´ŸÑÿßŸã ŸÑŸà ŸÇÿßŸÑ reject ‚Üí ŸÜŸÜŸÅÿ∞ rule ‚Äúÿßÿ≠ÿ™ÿ±ÿßŸÖ AI‚Äù ÿ£Ÿà ŸÑÿß)

ŸÜÿ≥ÿ¨ŸëŸÑ ÿ±ÿ£ŸäŸá ŸÅŸä ÿßŸÑŸÑŸàÿ¨.

ÿ®ÿπÿØ ÿ™ŸÜŸÅŸäÿ∞ order:

ŸÜÿ∑ŸÑÿ® ŸÖŸÜ AITradeExplainer ŸÜÿµ explanation

ÿ•ÿ∞ÿß ÿ™ŸäŸÑŸäÿ∫ÿ±ÿßŸÖ ŸÖŸÅÿπŸëŸÑ:

ŸÜÿ±ÿ≥ŸÑ ÿßŸÑŸÜÿµ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ

Telegram commands:

/explain_last ‚Üí Ÿäÿ¨Ÿäÿ® ÿ¢ÿÆÿ± ÿµŸÅŸÇÿ© + explanation

/explain_open ‚Üí Ÿäÿ¥ÿ±ÿ≠ ŸÉŸÑ ÿßŸÑÿµŸÅŸÇÿßÿ™ ÿßŸÑŸÖŸÅÿ™Ÿàÿ≠ÿ© ÿßŸÑÿ≠ÿßŸÑŸäŸëÿ©

/why_blocked ‚Üí Ÿäÿ¥ÿ±ÿ≠ ÿ¢ÿÆÿ± ÿµŸÅŸÇÿ© ÿ™ŸÖ ÿ≠ÿ∏ÿ±Ÿáÿß ŸÖŸÜ RiskManager

üìÑ 3) Data Models ŸÑÿ∑ÿ®ŸÇÿ© AI
ŸÖŸÑŸÅ: sagetrade/ai/models.py
# FILE: sagetrade/ai/models.py

from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, Literal, List

AISignalDecision = Literal["approve", "caution", "reject"]

@dataclass
class AISignalAdvice:
    symbol: str
    strategy_name: str
    decision: AISignalDecision
    reason: str
    suggested_direction: Optional[str] = None     # "long", "short", "flat"
    suggested_confidence: Optional[float] = None  # 0..1

@dataclass
class AITradeExplanation:
    symbol: str
    strategy_name: str
    title: str          # short title
    summary: str        # main explanation text
    risks: List[str]    # bullet list of risks
    notes: List[str]    # extra notes or suggestions

@dataclass
class AITradeReview:
    symbol: str
    strategy_name: str
    outcome: str        # "win" / "loss" / "breakeven"
    pnl: float
    lesson: str         # main lesson
    improvements: List[str]

ü§ñ 4) LLM Client abstraction
ŸÖŸÑŸÅ: sagetrade/ai/client.py
# FILE: sagetrade/ai/client.py

from __future__ import annotations
from abc import ABC, abstractmethod
from typing import Optional

from sagetrade.utils.config import get_settings
from sagetrade.utils.logging import get_logger

logger = get_logger(__name__)
_settings = get_settings()


class LLMClientBase(ABC):
    @abstractmethod
    def generate(self, prompt: str, *, max_tokens: Optional[int] = None) -> str:
        ...


class MockLLMClient(LLMClientBase):
    """
    Placeholder backend that returns a simple deterministic message.
    Replace later with actual provider (OpenAI, etc.).
    """
    def generate(self, prompt: str, *, max_tokens: Optional[int] = None) -> str:
        logger.debug("mock_llm_generate event=mock_llm_call prompt_length=%d", len(prompt))
        return (
            "AI (mock) analysis:\n"
            "Based on the provided signal and risk parameters, this trade looks reasonable. "
            "Risk should remain controlled as long as stop-loss and position sizing rules are respected."
        )


def get_llm_client() -> LLMClientBase:
    """
    Factory to get an LLM client based on config.
    For now, always return MockLLMClient, but structure is ready for real backend.
    """
    ai_cfg = _settings.ai
    provider = getattr(ai_cfg, "provider", "mock")
    # ŸÖÿ≥ÿ™ŸÇÿ®ŸÑÿßŸã:
    # if provider == "openai": return OpenAILLMClient(...)
    # ÿ•ŸÑÿÆ...
    logger.info("llm_client_init event=llm_client_init provider=%s model=%s", provider, ai_cfg.model)
    return MockLLMClient()


ŸÑÿßÿ≠ŸÇÿßŸã ŸÑŸÖÿß ÿ™ÿ≠ÿ® ÿ™ÿ±ÿ®ÿ∑Ÿá ÿ®ŸÄ OpenAI ÿ£Ÿà ÿ∫Ÿäÿ±Ÿá:

ÿ™ÿ∂ŸäŸÅ ŸÉŸÑÿßÿ≥ ŸÖÿ´ŸÑ OpenAILLMClient Ÿàÿ™ŸÇÿ±ÿ£ ÿßŸÑŸÖŸÅÿ™ÿßÿ≠ ŸÖŸÜ env.

üß† 5) AISignalAdvisor
ŸÖŸÑŸÅ: sagetrade/ai/signal_advisor.py
# FILE: sagetrade/ai/signal_advisor.py

from __future__ import annotations
from textwrap import dedent

from sagetrade.ai.client import get_llm_client
from sagetrade.ai.models import AISignalAdvice
from sagetrade.signals.composite import CompositeSignal
from sagetrade.risk.state import RiskState
from sagetrade.utils.config import get_settings
from sagetrade.utils.logging import get_logger

logger = get_logger(__name__)
_settings = get_settings()
_llm = get_llm_client()


def build_signal_prompt(
    symbol: str,
    strategy_name: str,
    signal: CompositeSignal,
    risk: RiskState,
) -> str:
    """
    Ÿäÿ®ŸÜŸä prompt ŸÜÿµŸä Ÿäÿ¥ÿ±ÿ≠ ŸÑŸÑŸÄ LLM Ÿàÿ∂ÿπ ÿßŸÑÿµŸÅŸÇÿ© ÿßŸÑŸÖŸÇÿ™ÿ±ÿ≠ÿ©.
    """
    q = signal.quant
    nlp = signal.nlp
    social = signal.social

    nlp_part = (
        f"- News sentiment: {nlp.sentiment:.3f}, impact_score: {nlp.impact_score:.3f}, flags: {nlp.event_flags}\n"
        if nlp is not None else
        "- News sentiment: N/A\n"
    )

    social_part = (
        f"- Social sentiment: {social.sentiment:.3f}, buzz_score: {social.buzz_score:.3f}, volume_score: {social.volume_score:.3f}\n"
        if social is not None else
        "- Social sentiment: N/A\n"
    )

    prompt = dedent(f"""
    You are an AI trading risk advisor. You receive a proposed trade based on quantitative and news/social signals.

    Symbol: {symbol}
    Strategy: {strategy_name}

    Quant signals:
    - SMA: {q.sma:.4f}
    - EMA: {q.ema:.4f}
    - RSI: {q.rsi:.2f}
    - ATR: {q.atr:.4f}
    - Volatility: {q.volatility:.4f}
    - Regime: {q.regime}

    News / NLP:
    {nlp_part}
    Social:
    {social_part}

    Composite signal:
    - Direction: {signal.direction}
    - Score: {signal.score:.4f}
    - Confidence: {signal.confidence:.3f}

    Risk state:
    - Current equity: {risk.equity:.2f}
    - Start equity: {risk.equity_start:.2f}
    - Daily PnL: {risk.daily_pnl:.2f}
    - Open trades: {risk.open_trades}
    - Total open notional: {risk.total_open_notional:.2f}

    TASK:
    1. Briefly evaluate if entering this trade NOW is reasonable (approve, caution, or reject).
    2. If you think it's better to stay flat, indicate direction 'flat'.
    3. Optionally suggest adjusting the confidence (0..1).
    4. Explain your reasoning in 2-3 short sentences.

    Respond in concise English in the following JSON-like format (do NOT include backticks):

    decision: <approve|caution|reject>
    suggested_direction: <long|short|flat|none>
    suggested_confidence: <0.0-1.0 or 'none'>
    reason: <one or two sentences>
    """).strip()

    return prompt


def review_trade_candidate(
    symbol: str,
    strategy_name: str,
    signal: CompositeSignal,
    risk: RiskState,
) -> AISignalAdvice:
    """
    Ÿäÿ≥ÿ™ÿØÿπŸä LLM ŸÑŸÖÿ±ÿßÿ¨ÿπÿ© ÿßŸÑÿµŸÅŸÇÿ© ÿßŸÑŸÖŸÇÿ™ÿ±ÿ≠ÿ©.
    ŸÑŸà ŸÅÿ¥ŸÑ ÿßŸÑŸÜÿØÿßÿ° ‚Üí Ÿäÿ±ÿ¨ÿπ advice ÿ®ÿ≥Ÿäÿ∑ rule-based.
    """
    prompt = build_signal_prompt(symbol, strategy_name, signal, risk)

    try:
        raw = _llm.generate(prompt, max_tokens=_settings.ai.max_tokens)
        logger.debug(
            "ai_signal_advisor_response event=ai_signal_advisor_response symbol=%s strategy=%s raw=%s",
            symbol,
            strategy_name,
            raw,
        )
        # ŸáŸÜÿß ŸÜÿπŸÖŸÑ parsing ÿ®ÿ≥Ÿäÿ∑ ŸÑŸÑÿÆÿ∑Ÿàÿ∑ (ÿ®ÿØŸÑ JSON parser ŸÉÿßŸÖŸÑ ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ©)
        decision = "approve"
        suggested_direction = None
        suggested_confidence = None
        reason = raw

        for line in raw.splitlines():
            line_lower = line.lower()
            if line_lower.startswith("decision:"):
                decision = line.split(":", 1)[1].strip()
            elif line_lower.startswith("suggested_direction:"):
                sd = line.split(":", 1)[1].strip()
                suggested_direction = None if sd in ("none", "") else sd
            elif line_lower.startswith("suggested_confidence:"):
                v = line.split(":", 1)[1].strip()
                if v.lower() in ("none", ""):
                    suggested_confidence = None
                else:
                    try:
                        suggested_confidence = float(v)
                    except ValueError:
                        suggested_confidence = None
            elif line_lower.startswith("reason:"):
                reason = line.split(":", 1)[1].strip()

        # ÿ∂ŸÖÿßŸÜ ÿµÿ≠ÿ© decision
        if decision not in ("approve", "caution", "reject"):
            decision = "approve"

        return AISignalAdvice(
            symbol=symbol,
            strategy_name=strategy_name,
            decision=decision, 
            reason=reason,
            suggested_direction=suggested_direction,
            suggested_confidence=suggested_confidence,
        )

    except Exception as exc:
        logger.error(
            "ai_signal_advisor_error event=ai_signal_advisor_error symbol=%s strategy=%s error=%s",
            symbol,
            strategy_name,
            exc,
        )
        # fallback rule-based ÿ®ÿ≥Ÿäÿ∑
        fallback_reason = "AI unavailable; fallback rule-based approval."
        return AISignalAdvice(
            symbol=symbol,
            strategy_name=strategy_name,
            decision="approve",
            reason=fallback_reason,
        )


ÿ´ŸÖ ÿØÿßÿÆŸÑ ÿßŸÑŸÑŸàÿ® ŸÇÿ®ŸÑ ÿ•ÿ±ÿ≥ÿßŸÑ order:

ÿ™ÿ≥ÿ™ÿØÿπŸä review_trade_candidate(...)

ŸÖŸÖŸÉŸÜ ÿ™ÿ∂ŸäŸÅ ŸÖŸÜÿ∑ŸÇ: ŸÑŸà decision="reject" ‚Üí ŸÑÿß ÿ™ÿ±ÿ≥ŸÑ ÿßŸÑÿµŸÅŸÇÿ©.

üìù 6) AITradeExplainer
ŸÖŸÑŸÅ: sagetrade/ai/trade_explainer.py
# FILE: sagetrade/ai/trade_explainer.py

from __future__ import annotations
from textwrap import dedent

from sagetrade.ai.client import get_llm_client
from sagetrade.ai.models import AITradeExplanation
from sagetrade.signals.composite import CompositeSignal
from sagetrade.risk.state import RiskState
from sagetrade.utils.logging import get_logger

logger = get_logger(__name__)
_llm = get_llm_client()


def _build_open_trade_prompt(
    symbol: str,
    strategy_name: str,
    side: str,
    qty: float,
    price: float,
    signal: CompositeSignal,
    risk: RiskState,
) -> str:
    q = signal.quant
    nlp = signal.nlp
    social = signal.social

    nlp_text = (
        f"News sentiment {nlp.sentiment:.3f} with impact {nlp.impact_score:.3f} and flags {nlp.event_flags}"
        if nlp is not None else "No specific news signal was available."
    )

    social_text = (
        f"Social sentiment {social.sentiment:.3f}, buzz {social.buzz_score:.3f}, volume_score {social.volume_score:.3f}"
        if social is not None else "No specific social signal was available."
    )

    prompt = dedent(f"""
    You are an AI trading assistant. Explain a newly opened trade in a concise, friendly way.

    Trade:
    - Symbol: {symbol}
    - Strategy: {strategy_name}
    - Side: {side}
    - Quantity: {qty:.4f}
    - Entry price: {price:.4f}

    Quant signals:
    - SMA: {q.sma:.4f}
    - EMA: {q.ema:.4f}
    - RSI: {q.rsi:.2f}
    - ATR: {q.atr:.4f}
    - Volatility: {q.volatility:.4f}
    - Regime: {q.regime}

    Composite signal:
    - Direction: {signal.direction}
    - Score: {signal.score:.4f}
    - Confidence: {signal.confidence:.3f}

    News / NLP: {nlp_text}
    Social: {social_text}

    Risk context:
    - Current equity: {risk.equity:.2f}
    - Start equity: {risk.equity_start:.2f}
    - Open trades: {risk.open_trades}
    - Total open notional: {risk.total_open_notional:.2f}

    TASK:
    1. Provide a short title summarizing the idea of the trade in one line.
    2. Provide a 3-5 sentence explanation aimed at a non-technical trader.
    3. List 2-4 key risks to monitor.
    4. Add 1-2 short notes or suggestions for managing the trade.

    Respond in a structured plain-text format (no JSON, no markdown):

    TITLE: <short title>
    SUMMARY: <one or two paragraphs>
    RISKS:
    - <risk 1>
    - <risk 2>
    NOTES:
    - <note 1>
    - <note 2>
    """).strip()

    return prompt


def explain_open_trade(
    symbol: str,
    strategy_name: str,
    side: str,
    qty: float,
    price: float,
    signal: CompositeSignal,
    risk: RiskState,
) -> AITradeExplanation:
    prompt = _build_open_trade_prompt(symbol, strategy_name, side, qty, price, signal, risk)

    try:
        raw = _llm.generate(prompt)
        logger.debug(
            "ai_trade_explainer_open event=ai_trade_explainer_open symbol=%s strategy=%s raw=%s",
            symbol,
            strategy_name,
            raw,
        )
        title = "New trade opened"
        summary = raw
        risks: list[str] = []
        notes: list[str] = []

        # parsing ÿ®ÿ≥Ÿäÿ∑:
        current_section = None
        for line in raw.splitlines():
            stripped = line.strip()
            if stripped.upper().startswith("TITLE:"):
                title = stripped.split(":", 1)[1].strip()
                current_section = None
            elif stripped.upper().startswith("SUMMARY:"):
                summary = stripped.split(":", 1)[1].strip()
                current_section = "SUMMARY"
            elif stripped.upper().startswith("RISKS:"):
                current_section = "RISKS"
            elif stripped.upper().startswith("NOTES:"):
                current_section = "NOTES"
            elif stripped.startswith("- "):
                item = stripped[2:].strip()
                if current_section == "RISKS":
                    risks.append(item)
                elif current_section == "NOTES":
                    notes.append(item)
            elif current_section == "SUMMARY":
                summary += " " + stripped

        return AITradeExplanation(
            symbol=symbol,
            strategy_name=strategy_name,
            title=title,
            summary=summary,
            risks=risks,
            notes=notes,
        )

    except Exception as exc:
        logger.error(
            "ai_trade_explainer_error event=ai_trade_explainer_error symbol=%s strategy=%s error=%s",
            symbol,
            strategy_name,
            exc,
        )
        return AITradeExplanation(
            symbol=symbol,
            strategy_name=strategy_name,
            title="New trade opened",
            summary="AI explanation not available; trade opened based on system rules and risk constraints.",
            risks=["Standard market volatility", "Unexpected news or events"],
            notes=["Monitor stop-loss levels", "Avoid over-leveraging"],
        )

üì≤ 7) ÿØŸÖÿ¨ AI ŸÖÿπ Telegram bot
ŸÅŸä config/settings.yaml ŸÜÿ∂ŸäŸÅ:
ai:
  provider: "mock"        # ÿ£Ÿà "openai" ŸÑÿßÿ≠ŸÇÿßŸã
  model: "gpt-4.1-mini"   # ÿßÿ≥ŸÖ ÿ¥ŸÉŸÑŸä ÿßŸÑÿ¢ŸÜ
  max_tokens: 512
  language: "en"          # ŸÑÿßÿ≠ŸÇÿßŸã ŸÖŸÖŸÉŸÜ ar/en mix

ŸÅŸä sagetrade/telegram/bot.py ÿ£Ÿà handlers.py

ÿ£ŸÅŸÉÿßÿ± ÿ£ŸàÿßŸÖÿ±:

/explain_last:

ÿ™ÿ¨Ÿäÿ® ÿ¢ÿÆÿ± ÿµŸÅŸÇÿ© ŸÖŸÜ broker

ÿ™ÿ¨Ÿäÿ® composite signal ÿßŸÑŸÑŸä ŸÅÿ™ÿ≠Ÿáÿß (ÿÆÿ≤ŸÜŸá ÿπŸÜÿØ ÿßŸÑŸÅÿ™ÿ≠)

ÿ™ÿ≥ÿ™ÿØÿπŸä explain_open_trade(...)

ÿ™ÿ®ÿπÿ´ ÿßŸÑŸÄ summary + risks ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ.

/ai_review:

ÿπŸÑŸâ ÿ¢ÿÆÿ± ÿ•ÿ¥ÿßÿ±ÿ©/ÿµŸÅŸÇÿ© ŸÖÿ±ŸÅŸàÿ∂ÿ© ÿ£Ÿà ŸÖŸÇÿ®ŸàŸÑÿ©

ÿ™ÿ≥ÿ™ÿØÿπŸä review_trade_candidate(...)

ÿ™ÿ±ÿ¨ÿπ decision + reason.

ŸÖÿ´ÿßŸÑ Handler ÿ®ÿ≥Ÿäÿ∑ ŸÑÿ£ŸÖÿ± /explain_last
# FILE: sagetrade/telegram/handlers.py  (ŸÅŸÉÿ±ÿ© ÿπÿßŸÖÿ©)

from sagetrade.ai.trade_explainer import explain_open_trade
from sagetrade.utils.logging import get_logger

logger = get_logger(__name__)

async def handle_explain_last(update, context):
    # pseudo-code:
    # 1) ÿßÿ≠ÿ∂ÿ± ÿ¢ÿÆÿ± position ŸÖŸÜ broker
    # 2) ÿßÿ≠ÿ∂ÿ± composite signal ÿßŸÑŸÖÿ≠ŸÅŸàÿ∏ ŸàŸÇÿ™ ÿßŸÑÿØÿÆŸàŸÑ (ÿ™ÿ≠ÿ™ÿßÿ¨ ÿ™ÿÆÿ≤ŸÜŸá ŸÅŸä ŸÖŸÉÿßŸÜ ŸÖÿß)
    # ŸáŸÜÿß ŸÜÿ∂ÿπ ŸáŸäŸÉŸÑ ÿ™ŸÇÿ±Ÿäÿ®Ÿä.
    chat_id = update.effective_chat.id
    broker = context.bot_data["broker"]
    risk_state = context.bot_data["risk_state"]

    last_pos = broker.get_last_open_or_closed_position()
    if last_pos is None:
        await context.bot.send_message(chat_id=chat_id, text="ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿµŸÅŸÇÿßÿ™ ŸÑÿ¥ÿ±ÿ≠Ÿáÿß ÿ≠ÿßŸÑŸäÿßŸã.")
        return

    symbol = last_pos.symbol
    strategy_name = last_pos.strategy_name
    side = last_pos.side
    qty = last_pos.qty
    price = last_pos.entry_price

    # composite_at_entry ÿ™ÿ≠ÿ™ÿßÿ¨ ÿ™ÿÆÿ≤ŸäŸÜŸáÿß ŸÅŸä ŸàŸÇÿ™ ŸÅÿ™ÿ≠ ÿßŸÑÿµŸÅŸÇÿ©ÿõ
    # ŸáŸÜÿß ŸÜŸÅÿ™ÿ±ÿ∂ ÿ£ŸÜŸÉ ÿ™ÿ≠ŸÅÿ∏Ÿáÿß ŸÅŸä dict ÿØÿßÿÆŸÑ broker ÿ£Ÿà engine
    composite = last_pos.meta.get("composite_signal")

    if composite is None:
        await context.bot.send_message(chat_id=chat_id, text="ŸÑÿß ŸäŸàÿ¨ÿØ ÿ≥ŸäÿßŸÇ ŸÉÿßŸÖŸÑ ŸÑŸÑÿµŸÅŸÇÿ©ÿå ŸÑŸÉŸÜ ÿ≥ÿ£ÿ≠ÿßŸàŸÑ ÿßŸÑÿ¥ÿ±ÿ≠ ŸÑÿßÿ≠ŸÇÿßŸã.")
        return

    expl = explain_open_trade(symbol, strategy_name, side, qty, price, composite, risk_state)
    text = (
        f"**{expl.title}**\n\n"
        f"{expl.summary}\n\n"
        f"*Risks:*\n" + "\n".join(f"- {r}" for r in expl.risks) +
        "\n\n*Notes:*\n" + "\n".join(f"- {n}" for n in expl.notes)
    )

    # ŸÑŸà ÿßŸÑÿ®Ÿàÿ™ ŸäÿØÿπŸÖ Markdown:
    await context.bot.send_message(chat_id=chat_id, text=text, parse_mode="Markdown")


ÿßŸÑŸÖŸáŸÖ ŸáŸÜÿß: ÿ£ŸÜÿ™ ÿ™ÿ¨Ÿáÿ≤ ÿßŸÑŸÄ plumbing. ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ (meta["composite_signal"]) ŸÜŸÇÿØÿ± ŸÜÿ∂ÿ®ÿ∑Ÿáÿß ŸÅŸä ŸÖÿ±ÿ≠ŸÑÿ© ŸÑÿßÿ≠ŸÇÿ©.

üßæ 8) ŸÖÿß ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ¨ÿßŸáÿ≤Ÿãÿß ÿ®ÿπÿØ Part 9ÿü

ÿ•ÿπÿØÿßÿØÿßÿ™ AI ŸÅŸä settings.yaml (ŸÇÿ≥ŸÖ ai)

ŸÖŸÑŸÅÿßÿ™ ÿ¨ÿØŸäÿØÿ©:

sagetrade/ai/models.py

sagetrade/ai/client.py

sagetrade/ai/signal_advisor.py

sagetrade/ai/trade_explainer.py

AISignalAdvisor ÿ¨ÿßŸáÿ≤ Ÿäÿ±ÿßÿ¨ÿπ ÿ£Ÿä ÿµŸÅŸÇÿ© ŸÇÿ®ŸÑ ÿßŸÑÿ™ŸÜŸÅŸäÿ∞ (ÿ≠ÿ™Ÿâ ŸÑŸà ÿ≠ÿßŸÑŸäÿßŸã mock LLM)

AITradeExplainer ÿ¨ÿßŸáÿ≤ Ÿäÿπÿ∑Ÿä ŸÜÿµ ÿ¥ÿ±ÿ≠ (Ÿäÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸä Telegram Ÿà logs)

ÿ™ŸÑÿ∫ÿ±ÿßŸÖ ŸÅŸäŸá ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ ÿ£ŸÖÿ± Ÿàÿßÿ≠ÿØ Ÿäÿ≥ÿ™ÿÆÿØŸÖ AI (ŸÖÿ´ŸÑ /explain_last)

ŸÅŸä ÿßŸÑŸÄ trading loop:

ÿµÿßÿ± ŸÅŸäŸá ÿÆÿ∑Ÿàÿ© ÿ•ÿ∂ÿßŸÅŸäÿ© ÿßÿÆÿ™Ÿäÿßÿ±Ÿäÿ©: ÿ≥ÿ§ÿßŸÑ ÿßŸÑŸÄ AISignalAdvisor ŸÇÿ®ŸÑ ÿ•ÿ±ÿ≥ÿßŸÑ order.

ü§ñ 9) Prompt ÿ¨ÿßŸáÿ≤ ÿ™ÿπÿ∑ŸäŸá ŸÑŸÄ AI Agent ŸÑŸäŸÜŸÅŸëÿ∞ Part 9

ÿßŸÜÿ≥ÿÆ Ÿáÿ∞ÿß ÿßŸÑŸÄ prompt Ÿàÿ£ÿ±ÿ≥ŸÑŸá ŸÑŸÑŸà agent ÿßŸÑŸÑŸä Ÿäÿ¥ÿ™ÿ∫ŸÑ ÿπŸÑŸâ ÿßŸÑÿ±Ÿäÿ®Ÿà:

You are a senior Python engineer and ML integration specialist working on my trading project SAGE SmartTrade.

CONTEXT:
- The project has:
  - CompositeSignal + strategies + RiskManager + trading loop.
  - A Telegram bot skeleton.
  - A config system using settings.yaml and Pydantic models.
- I now want to implement Phase 9: AI layer for signal review and trade explanations.

TASK:

1) Extend `config/settings.yaml` to include an `ai` section with fields:
   - provider (e.g. "mock" for now)
   - model (string)
   - max_tokens (int)
   - language (string, e.g. "en")

2) Create `sagetrade/ai/models.py` with dataclasses:
   - `AISignalAdvice`:
     - symbol: str
     - strategy_name: str
     - decision: Literal["approve", "caution", "reject"]
     - reason: str
     - suggested_direction: Optional[str]
     - suggested_confidence: Optional[float]
   - `AITradeExplanation`:
     - symbol: str
     - strategy_name: str
     - title: str
     - summary: str
     - risks: list[str]
     - notes: list[str]
   - `AITradeReview` (optional for future):
     - symbol: str
     - strategy_name: str
     - outcome: str
     - pnl: float
     - lesson: str
     - improvements: list[str]

3) Create `sagetrade/ai/client.py`:
   - Define abstract `LLMClientBase` with `generate(prompt: str, max_tokens: Optional[int] = None) -> str`.
   - Implement `MockLLMClient` that logs the call and returns a simple deterministic analysis string.
   - Implement `get_llm_client()` factory that reads `settings.ai.provider` and returns `MockLLMClient` for now.

4) Implement `sagetrade/ai/signal_advisor.py`:
   - A function `build_signal_prompt(symbol, strategy_name, signal: CompositeSignal, risk: RiskState) -> str`
     that assembles a detailed prompt with:
       - quant metrics (sma, ema, rsi, atr, volatility, regime)
       - news/nlp (sentiment, impact_score, flags) if available
       - social signals if available
       - composite direction, score, confidence
       - risk context (equity, equity_start, daily_pnl, open_trades, total_open_notional)
   - A function `review_trade_candidate(symbol, strategy_name, signal, risk) -> AISignalAdvice` that:
     - calls the LLM client with the prompt.
     - expects a structured plain-text response like:
       decision: <approve|caution|reject>
       suggested_direction: <long|short|flat|none>
       suggested_confidence: <0.0-1.0 or 'none'>
       reason: <...>
     - parses these lines into an `AISignalAdvice` instance.
     - on error, logs and returns a fallback `AISignalAdvice` with decision="approve" and a generic reason.

5) Implement `sagetrade/ai/trade_explainer.py`:
   - A helper `_build_open_trade_prompt(symbol, strategy_name, side, qty, price, signal: CompositeSignal, risk: RiskState) -> str`
     that describes the trade, quant & NLP signals, and risk context.
   - A function `explain_open_trade(symbol, strategy_name, side, qty, price, signal, risk) -> AITradeExplanation` that:
     - calls the LLM with a prompt instructing it to respond in this format:

       TITLE: <short title>
       SUMMARY: <one or two paragraphs>
       RISKS:
       - <risk 1>
       - <risk 2>
       NOTES:
       - <note 1>
       - <note 2>

     - parses the response into an `AITradeExplanation`.
     - on error, logs and returns a fallback explanation with generic content.

6) Integrate AISignalAdvisor into the main trading loop (e.g. `scripts/paper_trade_loop.py`):
   - After a strategy decides to enter and before submitting an order:
     - call `review_trade_candidate(symbol, strat.name, composite, risk_state)`.
     - log the AI decision and reason.
     - optionally, if decision == "reject", skip submitting the order.
     - optionally, if `suggested_direction` and `suggested_confidence` are provided, adjust the signal or just log them for now.

7) Integrate AITradeExplainer with Telegram (in `sagetrade/telegram/handlers.py` or equivalent):
   - Add a handler for a command like `/explain_last` that:
     - fetches the last trade (open or recently closed) from the broker or engine.
     - retrieves the stored CompositeSignal at entry time (from a `meta` field or similar).
     - calls `explain_open_trade(...)`.
     - sends the explanation (title, summary, risks, notes) to the user (Markdown or plain text).
   - Ensure errors are handled gracefully and logged.

STYLE:
- Use Python 3.11+ typing and dataclasses.
- Use existing config (`get_settings`) and logging helpers.
- Keep LLM integration abstract (no direct vendor-specific SDK code for now).
- Output all changes as code blocks with file paths, e.g.:

  # FILE: config/settings.yaml
  ...
  # FILE: sagetrade/ai/models.py
  ...
  # FILE: sagetrade/ai/client.py
  ...
  # FILE: sagetrade/ai/signal_advisor.py
  ...
  # FILE: sagetrade/ai/trade_explainer.py
  ...
  # FILE: sagetrade/telegram/handlers.py
  ...
  # FILE: scripts/paper_trade_loop.py
  ...
